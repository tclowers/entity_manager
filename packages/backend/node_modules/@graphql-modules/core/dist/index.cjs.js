'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const graphqlTools = require('graphql-tools');
const schemaMerging = require('@graphql-toolkit/schema-merging');
const common = require('@graphql-toolkit/common');
const di = require('@graphql-modules/di');
const graphql = require('graphql');
const deepmerge = require('deepmerge');
const apolloServerCaching = require('apollo-server-caching');

class DependencyModuleNotFoundError extends Error {
    constructor(_dependency, _dependent) {
        super(`
      GraphQL-Modules Error: Dependency Module Not Found!
      - Module #${_dependency} couldn't be imported into #${_dependent}
      -- Module #${_dependency} is not defined in that scope!

      Possible solutions:
      - If you're using 'forRoot' on the upper import, use 'forChild' on the children imports.
      - If you're using 'forChild' on the parent imports, use 'forRoot' on the upper import.
  `);
        this._dependency = _dependency;
        this._dependent = _dependent;
        Object.setPrototypeOf(this, DependencyModuleNotFoundError.prototype);
        Error.captureStackTrace(this, DependencyModuleNotFoundError);
    }
    get dependency() {
        return this._dependency;
    }
    get dependent() {
        return this._dependent;
    }
}

class SchemaNotValidError extends Error {
    constructor(moduleName, error) {
        super(`
      GraphQL-Modules Error: Schema is not valid!
      - #Module #${moduleName} doesn't have a valid schema!
      -- ${error}

      Possible solutions:
      - Check syntax errors in typeDefs
      - Make sure you import correct dependencies
    `);
        Object.setPrototypeOf(this, SchemaNotValidError.prototype);
        Error.captureStackTrace(this, SchemaNotValidError);
    }
}

class DependencyModuleUndefinedError extends Error {
    constructor(_dependency) {
        super(`
      GraphQL-Modules Error: Dependency Module Undefined!
      - Module #${_dependency} is trying to import an undefined module declaration

      Possible solutions:
      - Circular imports may be used; so try to import modules like below;
        imports: () => [
          FooModule,
          BarModule
        ]
  `);
        this._dependency = _dependency;
        Object.setPrototypeOf(this, DependencyModuleUndefinedError.prototype);
        Error.captureStackTrace(this, DependencyModuleUndefinedError);
    }
    get dependency() {
        return this._dependency;
    }
}

class TypeDefNotFoundError extends Error {
    constructor(_typeName, _dependent) {
        super(`
      GraphQL-Modules Error: typeDef Not Found!
      - TypeDef '${_typeName}' not found in Module #${_dependent} scope!

      Possible solutions:
      - Check if you have this typeDef in that module's typeDefs.
      - Check if you have the module of this typeDef imported in your dependent modules.
    `);
        this._typeName = _typeName;
        this._dependent = _dependent;
        Object.setPrototypeOf(this, TypeDefNotFoundError.prototype);
        Error.captureStackTrace(this, TypeDefNotFoundError);
    }
    get typeName() {
        return this._typeName;
    }
    get dependent() {
        return this._dependent;
    }
}

class ProviderClassNotDecoratedError extends Error {
    constructor(_moduleName, _serviceIdentifier, _className) {
        super(`
      GraphQL-Modules Error: Provider is not decorated!
      - Module #${_moduleName} provides a provider with a non-decorated ${_className}.

      Possible solutions:
      - Check if Class #${_className} decorated with @Injectable()
    `);
        this._moduleName = _moduleName;
        this._serviceIdentifier = _serviceIdentifier;
        this._className = _className;
        Object.setPrototypeOf(this, ProviderClassNotDecoratedError.prototype);
        Error.captureStackTrace(this, ProviderClassNotDecoratedError);
    }
    get moduleName() {
        return this._moduleName;
    }
    get serviceIdentifier() {
        return this._serviceIdentifier;
    }
    get className() {
        return this._className;
    }
}

class ModuleConfigRequiredError extends Error {
    constructor(_moduleName) {
        super(`
      GraphQL-Modules Error: Module needs a configuration object!
      - #Module #${_moduleName} isn't imported by a configuration object.

      Possible solutions:
      - You should pass a valid configuration to import this module using forRoot.
      - If you already pass a configuration object with forRoot in somewhere in the application.
        You must import that module with forChild in other modules.
    `);
        this._moduleName = _moduleName;
        Object.setPrototypeOf(this, ModuleConfigRequiredError.prototype);
        Error.captureStackTrace(this, ModuleConfigRequiredError);
    }
    get moduleName() {
        return this._moduleName;
    }
}

class ModuleSessionInfo {
    constructor(_module, _session) {
        this._module = _module;
        this._session = _session;
        this.injector.provide({
            provide: ModuleSessionInfo,
            useValue: this,
            overwrite: true,
        });
    }
    get module() {
        return this._module;
    }
    get session() {
        return this._session;
    }
    get cache() {
        return this.module.selfCache;
    }
    get injector() {
        return this.module.injector.getSessionInjector(this.session);
    }
    get injectorAsync() {
        return this.module.injectorAsync.then(injector => injector.getSessionInjector(this.session));
    }
    get config() {
        return this.module.config;
    }
    get name() {
        return this.module.name;
    }
}

const asArray = (fns) => (Array.isArray(fns) ? fns : [fns]);
function normalizeSession(session) {
    // tslint:disable-next-line:no-console
    if ('session' in session) {
        session = session['session'];
    }
    if ('connection' in session && 'context' in session['connection']) {
        session = session['connection']['context']['session'];
    }
    return session;
}

/**
 * Returns a dependency injection token for getting a module's configuration object by
 * the module's name.
 * You can use this later with `@Inject` in your `Provider`s.
 *
 * @param module
 * @constructor
 */
const ModuleConfig = (module) => {
    if (module instanceof Function) {
        module = module();
    }
    if (module instanceof GraphQLModule) {
        module = module.name;
    }
    return Symbol.for(`ModuleConfig.${module}`);
};
/**
 * Represents a GraphQL module that has it's own types, resolvers, context and business logic.
 * You can read more about it in the Documentation section. {@link /docs/introduction/modules}
 *
 * You can also specific `Config` generic to tell TypeScript what's the structure of your
 * configuration object to use later with `forRoot`
 */
let GraphQLModule = /** @class */ (() => {
    class GraphQLModule {
        /**
         * Creates a new `GraphQLModule` instance, merged it's type definitions and resolvers.
         * @param options - module configuration
         */
        constructor(_options = {}, _moduleConfig) {
            this._options = _options;
            this._moduleConfig = _moduleConfig;
            this._cache = {
                injector: undefined,
                schema: undefined,
                typeDefs: undefined,
                resolvers: undefined,
                schemaDirectives: undefined,
                contextBuilder: undefined,
                extraSchemas: undefined,
                directiveResolvers: undefined,
                subscriptionHooks: undefined,
                imports: undefined,
                selfKeyValueCache: undefined,
                selfLogger: undefined
            };
            this._cacheAsync = {
                schemaAsync: undefined,
                typeDefsAsync: undefined,
                resolversAsync: undefined,
                injectorAsync: undefined
            };
            this._exclusionsFromSchema = new Array();
            this.paramsOnOperationResult$Map = new WeakMap();
            this.opIdOnOperationCompleteResult$Map = new WeakMap();
            this._sessionContext$Map = new WeakMap();
        }
        /**
         * Creates another instance of the module using a configuration
         * @param config - the config object
         */
        forRoot(config) {
            this._moduleConfig = {
                ...this._moduleConfig,
                ...config
            };
            // clean cache
            this._cache = {
                injector: undefined,
                schema: undefined,
                typeDefs: undefined,
                resolvers: undefined,
                schemaDirectives: undefined,
                contextBuilder: undefined,
                extraSchemas: undefined,
                directiveResolvers: undefined,
                subscriptionHooks: undefined,
                imports: undefined,
                selfKeyValueCache: undefined,
                selfLogger: undefined
            };
            return this;
        }
        forChild(config) {
            if (config) {
                return new GraphQLModule(this._options, {
                    ...this._moduleConfig,
                    ...config
                });
            }
            else {
                return this;
            }
        }
        withExclusionsFromSchema(exclusionsFromSchema) {
            const newModule = new GraphQLModule(this._options, this._moduleConfig);
            newModule._exclusionsFromSchema = exclusionsFromSchema;
            return newModule;
        }
        clearCache() {
            this._cache = {
                injector: undefined,
                schema: undefined,
                typeDefs: undefined,
                resolvers: undefined,
                schemaDirectives: undefined,
                contextBuilder: undefined,
                extraSchemas: undefined,
                directiveResolvers: undefined,
                subscriptionHooks: undefined,
                imports: undefined,
                selfKeyValueCache: undefined,
                selfLogger: undefined
            };
        }
        mock(partialCache) {
            if (partialCache.contextBuilder) {
                const providedContextBuilder = partialCache.contextBuilder;
                partialCache.contextBuilder = async (session, excludeSession) => {
                    session = normalizeSession(session);
                    const moduleSessionInfo = new ModuleSessionInfo(this, session);
                    const sessionInjector = moduleSessionInfo.injector;
                    sessionInjector.onInstanceCreated = ({ instance }) => {
                        if (typeof instance !== 'number' &&
                            typeof instance !== 'boolean' &&
                            typeof instance !== 'string' &&
                            'initialize' in instance &&
                            typeof instance['initialize'] === 'function') {
                            instance['initialize']({ cache: this.selfCache, context: moduleSessionInfo.context });
                        }
                    };
                    await sessionInjector.callHookWithArgs({
                        hook: 'onRequest',
                        args: [moduleSessionInfo],
                        instantiate: true,
                        async: true
                    });
                    return {
                        injector: sessionInjector,
                        ...(await providedContextBuilder(session, excludeSession))
                    };
                };
            }
            this._cache = {
                ...this._cache,
                ...partialCache
            };
            return this;
        }
        resetMock() {
            this.clearCache();
            return this;
        }
        checkConfiguration() {
            if (this._options.configRequired && !this._moduleConfig) {
                throw new ModuleConfigRequiredError(this.name);
            }
        }
        get name() {
            if (!this._options.name) {
                const getFilename = (id) => id.split('/').pop();
                const generateName = () => {
                    const randomId = Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER)).toString();
                    if (typeof module !== 'undefined' && module.parent && module.parent.parent) {
                        return getFilename(module.parent.parent.id) + '_' + randomId;
                    }
                    return randomId;
                };
                this._options.name = generateName();
            }
            return this._options.name;
        }
        get config() {
            return this._moduleConfig;
        }
        /**
         * Gets the application `GraphQLSchema` object.
         * If the schema object is not built yet, it compiles
         * the `typeDefs` and `resolvers` into `GraphQLSchema`
         */
        get schema() {
            if (typeof this._cache.schema === 'undefined') {
                this.checkConfiguration();
                const selfImports = this.selfImports;
                const importsSchemas = selfImports.map(module => module.schema).filter(Boolean);
                try {
                    const selfTypeDefs = this.selfTypeDefs;
                    const selfEncapsulatedResolvers = this.addSessionInjectorToSelfResolversContext(this.selfResolvers);
                    const selfEncapsulatedResolversComposition = this.addSessionInjectorToSelfResolversCompositionContext(this.selfResolversComposition);
                    const selfResolverValidationOptions = this.selfResolverValidationOptions;
                    const selfExtraSchemas = this.selfExtraSchemas;
                    if (importsSchemas.length || selfTypeDefs || selfExtraSchemas.length) {
                        const schema = schemaMerging.mergeSchemas({
                            schemas: [...importsSchemas, ...selfExtraSchemas],
                            typeDefs: selfTypeDefs || undefined,
                            resolvers: selfEncapsulatedResolvers,
                            resolversComposition: selfEncapsulatedResolversComposition,
                            resolverValidationOptions: selfResolverValidationOptions,
                            logger: 'clientError' in this.selfLogger
                                ? {
                                    log: message => this.selfLogger.clientError(message)
                                }
                                : undefined,
                            exclusions: this._exclusionsFromSchema
                        });
                        if (this._options.visitSchemaDirectives) {
                            graphqlTools.SchemaDirectiveVisitor.visitSchemaDirectives(schema, this.schemaDirectives);
                        }
                        this._cache.schema = schema;
                    }
                    else {
                        this._cache.schema = null;
                    }
                }
                catch (e) {
                    if (e.message === 'Must provide typeDefs') {
                        this._cache.schema = null;
                    }
                    else if (e.message.includes(`Type "`) && e.message.includes(`" not found in document.`)) {
                        const typeDef = e.message.replace('Type "', '').replace('" not found in document.', '');
                        throw new TypeDefNotFoundError(typeDef, this.name);
                    }
                    else {
                        throw new SchemaNotValidError(this.name, e.message);
                    }
                }
                if ('middleware' in this._options) {
                    const middlewareResult = this.injector.call(this._options.middleware, this);
                    Object.assign(this._cache, middlewareResult);
                }
            }
            return this._cache.schema;
        }
        get schemaAsync() {
            if (typeof this._cache.schema === 'undefined') {
                if (typeof this._cacheAsync.schemaAsync === 'undefined') {
                    this._cacheAsync.schemaAsync = new Promise(async (resolve, reject) => {
                        try {
                            if (!this._cache.schema) {
                                this.checkConfiguration();
                                try {
                                    const selfTypeDefsAsync$ = this.selfTypeDefsAsync;
                                    const selfEncapsulatedResolversAsync$ = this.selfResolversAsync.then(selfResolvers => this.addSessionInjectorToSelfResolversContext(selfResolvers));
                                    const [selfTypeDefs, selfEncapsulatedResolvers, selfExtraSchemas, importsSchemas] = await Promise.all([
                                        selfTypeDefsAsync$,
                                        selfEncapsulatedResolversAsync$,
                                        Promise.resolve().then(() => this.selfExtraSchemas),
                                        Promise.resolve().then(() => Promise.all(this.selfImports.map(module => module.schemaAsync)))
                                    ]);
                                    const selfEncapsulatedResolversComposition = this.addSessionInjectorToSelfResolversCompositionContext(this.selfResolversComposition);
                                    const selfLogger = this.selfLogger;
                                    const selfResolverValidationOptions = this.selfResolverValidationOptions;
                                    const validImportsSchema = importsSchemas.filter(Boolean);
                                    if (validImportsSchema.length || selfTypeDefs || selfExtraSchemas.length) {
                                        const schema = await schemaMerging.mergeSchemasAsync({
                                            schemas: [...validImportsSchema, ...selfExtraSchemas].filter(Boolean),
                                            typeDefs: selfTypeDefs || undefined,
                                            resolvers: selfEncapsulatedResolvers,
                                            resolversComposition: selfEncapsulatedResolversComposition,
                                            resolverValidationOptions: selfResolverValidationOptions,
                                            logger: 'clientError' in selfLogger
                                                ? {
                                                    log: (message) => selfLogger.clientError(message)
                                                }
                                                : undefined,
                                            exclusions: this._exclusionsFromSchema
                                        });
                                        if (this._options.visitSchemaDirectives) {
                                            graphqlTools.SchemaDirectiveVisitor.visitSchemaDirectives(schema, this.schemaDirectives);
                                        }
                                        this._cache.schema = schema;
                                    }
                                    else {
                                        this._cache.schema = null;
                                    }
                                }
                                catch (e) {
                                    if (e.message === 'Must provide typeDefs') {
                                        this._cache.schema = null;
                                    }
                                    else if (e.message.includes(`Type "`) && e.message.includes(`" not found in document.`)) {
                                        const typeDef = e.message.replace('Type "', '').replace('" not found in document.', '');
                                        throw new TypeDefNotFoundError(typeDef, this.name);
                                    }
                                    else {
                                        throw new SchemaNotValidError(this.name, e.message);
                                    }
                                }
                                if ('middleware' in this._options) {
                                    const middlewareResult = this.injector.call(this._options.middleware, this);
                                    Object.assign(this._cache, middlewareResult);
                                }
                            }
                            resolve(this._cache.schema);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                }
                return this._cacheAsync.schemaAsync;
            }
            return Promise.resolve(this._cache.schema);
        }
        /**
         * Gets the application dependency-injection injector
         */
        get injector() {
            if (typeof this._cache.injector === 'undefined') {
                this.checkConfiguration();
                const injector = (this._cache.injector = new di.Injector({
                    name: this.name,
                    injectorScope: di.ProviderScope.Application,
                    defaultProviderScope: this.selfDefaultProviderScope,
                    hooks: [
                        'onInit',
                        'onRequest',
                        'onResponse',
                        'onError',
                        'onConnect',
                        'onOperation',
                        'onOperationComplete',
                        'onDisconnect'
                    ],
                    initialProviders: this.selfProviders,
                    children: this.selfImports.map(module => module.injector)
                }));
                injector.onInstanceCreated = ({ instance }) => {
                    if (typeof instance !== 'number' &&
                        typeof instance !== 'boolean' &&
                        typeof instance !== 'string' &&
                        'initialize' in instance &&
                        typeof instance['initialize'] === 'function') {
                        instance['initialize']({ cache: this.selfCache });
                    }
                };
                injector.callHookWithArgs({
                    hook: 'onInit',
                    args: [this],
                    instantiate: true,
                    async: false
                });
            }
            return this._cache.injector;
        }
        get injectorAsync() {
            if (typeof this._cache.injector === 'undefined') {
                if (typeof this._cacheAsync.injectorAsync === 'undefined') {
                    this._cacheAsync.injectorAsync = new Promise(async (resolve, reject) => {
                        try {
                            this.checkConfiguration();
                            const [initialProviders, children] = await Promise.all([
                                Promise.resolve().then(() => this.selfProviders),
                                Promise.resolve().then(() => Promise.all(this.selfImports.map(module => module.injectorAsync)))
                            ]);
                            const injector = (this._cache.injector = new di.Injector({
                                name: this.name,
                                injectorScope: di.ProviderScope.Application,
                                defaultProviderScope: this.selfDefaultProviderScope,
                                hooks: [
                                    'onInit',
                                    'onRequest',
                                    'onResponse',
                                    'onError',
                                    'onConnect',
                                    'onOperation',
                                    'onOperationComplete',
                                    'onDisconnect'
                                ],
                                initialProviders,
                                children
                            }));
                            injector.onInstanceCreated = ({ instance }) => {
                                if (typeof instance !== 'number' &&
                                    typeof instance !== 'boolean' &&
                                    typeof instance !== 'string' &&
                                    'initialize' in instance &&
                                    typeof instance['initialize'] === 'function') {
                                    instance['initialize']({ cache: this.selfCache });
                                }
                            };
                            await injector.callHookWithArgs({
                                hook: 'onInit',
                                args: [this],
                                instantiate: true,
                                async: true
                            });
                            resolve(this._cache.injector);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                }
                return this._cacheAsync.injectorAsync;
            }
            return Promise.resolve(this._cache.injector);
        }
        get extraSchemas() {
            if (typeof this._cache.extraSchemas) {
                const selfImports = this.selfImports;
                const importsExtraSchemas = selfImports
                    .map(module => module.extraSchemas)
                    .reduce((extraSchemas, moduleExtraSchemas) => extraSchemas.concat(moduleExtraSchemas), []);
                const selfExtraSchemas = this.selfExtraSchemas;
                this._cache.extraSchemas = importsExtraSchemas.concat(selfExtraSchemas);
            }
            return this._cache.extraSchemas;
        }
        /**
         * Gets the merged GraphQL type definitions as one string
         */
        get typeDefs() {
            if (typeof this._cache.typeDefs === 'undefined') {
                let typeDefsArr = new Array();
                const selfImports = this.selfImports;
                for (const module of selfImports) {
                    const moduleTypeDefs = module.typeDefs;
                    if (moduleTypeDefs) {
                        typeDefsArr.push(moduleTypeDefs);
                    }
                }
                const selfTypeDefs = this.selfTypeDefs;
                if (selfTypeDefs) {
                    typeDefsArr.push(selfTypeDefs);
                }
                typeDefsArr = typeDefsArr.concat(this.extraSchemas);
                if (typeDefsArr.length) {
                    this._cache.typeDefs = schemaMerging.mergeTypeDefs(typeDefsArr, {
                        exclusions: this._exclusionsFromSchema,
                        useSchemaDefinition: false
                    });
                }
                else {
                    this._cache.typeDefs = null;
                }
            }
            return this._cache.typeDefs;
        }
        get typeDefsAsync() {
            if (typeof this._cache.typeDefs === 'undefined') {
                if (typeof this._cacheAsync.typeDefsAsync) {
                    this._cacheAsync.typeDefsAsync = new Promise(async (resolve, reject) => {
                        try {
                            const [extraSchemas, importsTypeDefs, selfTypeDefs] = await Promise.all([
                                Promise.resolve().then(() => this.selfExtraSchemas),
                                Promise.all(this.selfImports.map(module => module.typeDefsAsync)),
                                this.selfTypeDefsAsync
                            ]);
                            const typeDefs = importsTypeDefs.concat(extraSchemas).concat(selfTypeDefs);
                            if (typeDefs.length) {
                                this._cache.typeDefs = schemaMerging.mergeTypeDefs(typeDefs.filter(Boolean), {
                                    exclusions: this._exclusionsFromSchema,
                                    useSchemaDefinition: false
                                });
                            }
                            else {
                                this._cache.typeDefs = null;
                            }
                            resolve(this._cache.typeDefs);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                }
                return this._cacheAsync.typeDefsAsync;
            }
            return Promise.resolve(this._cache.typeDefs);
        }
        get resolvers() {
            if (typeof this._cache.resolvers === 'undefined') {
                const resolversToBeComposed = new Array();
                const selfImports = this.selfImports;
                for (const module of selfImports) {
                    const moduleResolvers = module.resolvers;
                    resolversToBeComposed.push(moduleResolvers);
                }
                const resolvers = this.addSessionInjectorToSelfResolversContext(this.selfResolvers);
                const resolversComposition = this.addSessionInjectorToSelfResolversCompositionContext(this.selfResolversComposition);
                resolversToBeComposed.push(resolvers);
                const composedResolvers = common.composeResolvers(schemaMerging.mergeResolvers(resolversToBeComposed, {
                    exclusions: this._exclusionsFromSchema
                }), resolversComposition);
                this._cache.resolvers = composedResolvers;
            }
            return this._cache.resolvers;
        }
        get resolversAsync() {
            if (typeof this._cache.resolvers === 'undefined') {
                if (typeof this._cacheAsync.resolversAsync === 'undefined') {
                    this._cacheAsync.resolversAsync = new Promise(async (resolve, reject) => {
                        try {
                            const resolversToBeComposed = await Promise.all([
                                ...this.selfImports.map(module => module.resolversAsync),
                                this.selfResolversAsync.then(selfResolvers => this.addSessionInjectorToSelfResolversContext(selfResolvers))
                            ]);
                            const resolversComposition = this.addSessionInjectorToSelfResolversCompositionContext(this.selfResolversComposition);
                            const composedResolvers = common.composeResolvers(schemaMerging.mergeResolvers(resolversToBeComposed, {
                                exclusions: this._exclusionsFromSchema
                            }), resolversComposition);
                            this._cache.resolvers = composedResolvers;
                            resolve(this._cache.resolvers);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                }
                return this._cacheAsync.resolversAsync;
            }
            return Promise.resolve(this._cache.resolvers);
        }
        get schemaDirectives() {
            if (typeof this._cache.schemaDirectives === 'undefined') {
                const schemaDirectivesSet = new Array();
                const selfImports = this.selfImports;
                for (const module of selfImports) {
                    const moduleSchemaDirectives = module.schemaDirectives;
                    schemaDirectivesSet.push(moduleSchemaDirectives);
                }
                const selfSchemaDirectives = this.selfSchemaDirectives;
                const selfDirectiveResolvers = this.selfDirectiveResolvers;
                for (const directiveName in selfDirectiveResolvers) {
                    selfSchemaDirectives[directiveName] = common.getSchemaDirectiveFromDirectiveResolver(selfDirectiveResolvers[directiveName]);
                }
                schemaDirectivesSet.push(selfSchemaDirectives);
                this._cache.schemaDirectives = deepmerge.all([...schemaDirectivesSet]);
            }
            return this._cache.schemaDirectives;
        }
        get subscriptions() {
            if (typeof this._cache.subscriptionHooks === 'undefined') {
                const subscriptionHooks = new Array();
                const selfImports = this.selfImports;
                for (const module of selfImports) {
                    const moduleSubscriptionHooks = module.subscriptions;
                    if (moduleSubscriptionHooks) {
                        subscriptionHooks.push(moduleSubscriptionHooks);
                    }
                }
                this._cache.subscriptionHooks = {
                    onConnect: (connectionParams, websocket, connectionContext) => {
                        if (!this._sessionContext$Map.has(websocket)) {
                            this._sessionContext$Map.set(websocket, new Promise(async (resolve, reject) => {
                                try {
                                    const importsOnConnectHooks$ = subscriptionHooks.map(async ({ onConnect }) => onConnect && onConnect(connectionParams, websocket, connectionContext));
                                    const importsOnConnectHooks = await Promise.all(importsOnConnectHooks$);
                                    const importsResult = importsOnConnectHooks.reduce((acc, curr) => ({ ...acc, ...(curr || {}) }), {});
                                    const connectionModuleContext = await this.context(connectionContext);
                                    const sessionInjector = connectionModuleContext.injector;
                                    const hookResult = Object.assign({}, ...(await Promise.all([
                                        sessionInjector.callHookWithArgs({
                                            hook: 'onConnect',
                                            args: [connectionParams, websocket, connectionContext],
                                            instantiate: true,
                                            async: true
                                        }),
                                        this._options.subscriptionHooks &&
                                            this._options.subscriptionHooks.onConnect &&
                                            this._options.subscriptionHooks.onConnect(connectionParams, websocket, connectionContext)
                                    ])));
                                    resolve({
                                        ...importsResult,
                                        ...connectionModuleContext,
                                        ...hookResult
                                    });
                                }
                                catch (e) {
                                    reject(e);
                                }
                            }));
                        }
                        return this._sessionContext$Map.get(websocket);
                    },
                    onOperation: (message, params, websocket) => {
                        if (!this.paramsOnOperationResult$Map.has(params)) {
                            this.paramsOnOperationResult$Map.set(params, new Promise(async (resolve, reject) => {
                                try {
                                    const importsOnOperationHooks$ = subscriptionHooks.map(async ({ onOperation }) => onOperation && onOperation(message, params, websocket));
                                    const importsOnOperationHooks = await Promise.all(importsOnOperationHooks$);
                                    const importsResult = importsOnOperationHooks.reduce((acc, curr) => ({ ...acc, ...(curr || {}) }), {});
                                    const connectionModuleContext = await this.context(params.context);
                                    const sessionInjector = connectionModuleContext.injector;
                                    const moduleOnOperationResult = Object.assign({}, ...(await Promise.all([
                                        sessionInjector.callHookWithArgs({
                                            hook: 'onOperation',
                                            args: [message, params, websocket],
                                            instantiate: true,
                                            async: true
                                        }),
                                        this._options.subscriptionHooks &&
                                            this._options.subscriptionHooks.onOperation &&
                                            this._options.subscriptionHooks.onOperation(message, params, websocket)
                                    ])));
                                    resolve({
                                        ...importsResult,
                                        ...moduleOnOperationResult,
                                        ...params
                                    });
                                }
                                catch (e) {
                                    reject(e);
                                }
                            }));
                        }
                        return this.paramsOnOperationResult$Map.get(params);
                    },
                    onOperationComplete: (websocket, opId) => {
                        opId = new String(opId);
                        if (!this.opIdOnOperationCompleteResult$Map.has(opId)) {
                            this.opIdOnOperationCompleteResult$Map.set(opId, new Promise(async (resolve, reject) => {
                                try {
                                    const importsOnOperationCompleteHooks$ = subscriptionHooks.map(async ({ onOperationComplete }) => onOperationComplete && onOperationComplete(websocket, opId));
                                    const importsOnOperationCompleteHooks = await Promise.all(importsOnOperationCompleteHooks$);
                                    const importsResult = importsOnOperationCompleteHooks.reduce((acc, curr) => ({ ...acc, ...(curr || {}) }), {});
                                    const connectionModuleContext = await this.context(websocket);
                                    const sessionInjector = connectionModuleContext.injector;
                                    const moduleOnOperationCompleteResult = Object.assign({}, ...(await Promise.all([
                                        sessionInjector.callHookWithArgs({
                                            hook: 'onOperationComplete',
                                            args: [websocket, opId],
                                            instantiate: true,
                                            async: true
                                        }),
                                        this._options.subscriptionHooks &&
                                            this._options.subscriptionHooks.onOperationComplete &&
                                            this._options.subscriptionHooks.onOperationComplete(websocket, opId)
                                    ])));
                                    resolve({
                                        ...importsResult,
                                        ...moduleOnOperationCompleteResult
                                    });
                                }
                                catch (e) {
                                    reject(e);
                                }
                            }));
                        }
                        return this.opIdOnOperationCompleteResult$Map.get(opId);
                    },
                    onDisconnect: (websocket, connectionContext) => {
                        websocket['_moduleOnDisconnect$Map'] = websocket['_moduleOnDisconnect$Map'] || new WeakMap();
                        const moduleOnDisconnect$Map = websocket['_moduleOnDisconnect$Map'];
                        if (!moduleOnDisconnect$Map.has(this)) {
                            moduleOnDisconnect$Map.set(this, new Promise(async (resolve, reject) => {
                                try {
                                    const importsOnDisconnectHooks$ = subscriptionHooks.map(async ({ onDisconnect }) => onDisconnect && onDisconnect(websocket, connectionContext));
                                    const importsOnDisconnectHooks = await Promise.all(importsOnDisconnectHooks$);
                                    importsOnDisconnectHooks.reduce((acc, curr) => ({ ...acc, ...(curr || {}) }), {});
                                    const connectionModuleContext = await this.context(connectionContext);
                                    const sessionInjector = connectionModuleContext.injector;
                                    await Promise.all([
                                        sessionInjector.callHookWithArgs({
                                            hook: 'onDisconnect',
                                            args: [websocket, connectionContext],
                                            instantiate: true,
                                            async: true
                                        }),
                                        this._options.subscriptionHooks &&
                                            this._options.subscriptionHooks.onDisconnect &&
                                            this._options.subscriptionHooks.onDisconnect(websocket, connectionContext)
                                    ]);
                                    this.destroySelfSession(websocket);
                                    resolve();
                                }
                                catch (e) {
                                    reject(e);
                                }
                            }));
                        }
                        return moduleOnDisconnect$Map.get(this);
                    }
                };
            }
            return this._cache.subscriptionHooks;
        }
        get selfDefaultProviderScope() {
            let defaultProviderScope = di.ProviderScope.Application;
            const defaultProviderScopeDefinition = this._options.defaultProviderScope;
            if (defaultProviderScopeDefinition) {
                if (typeof defaultProviderScopeDefinition === 'function') {
                    defaultProviderScope = defaultProviderScopeDefinition(this);
                }
                else {
                    defaultProviderScope = defaultProviderScopeDefinition;
                }
            }
            return defaultProviderScope;
        }
        get selfExtraSchemas() {
            let extraSchemas = new Array();
            const extraSchemasDefinitions = this._options.extraSchemas;
            if (extraSchemasDefinitions) {
                if (typeof extraSchemasDefinitions === 'function') {
                    this.checkConfiguration();
                    extraSchemas = extraSchemasDefinitions(this);
                }
                else {
                    extraSchemas = extraSchemasDefinitions;
                }
            }
            return extraSchemas;
        }
        /**
         * Returns the GraphQL type definitions of the module
         * @return a `string` with the merged type definitions
         */
        get selfTypeDefs() {
            let typeDefs = null;
            let typeDefsDefinitions = this._options.typeDefs;
            if (typeDefsDefinitions) {
                if (typeof typeDefsDefinitions === 'function') {
                    this.checkConfiguration();
                    typeDefsDefinitions = typeDefsDefinitions(this);
                }
                if (typeof typeDefsDefinitions === 'string') {
                    typeDefs = graphql.parse(typeDefsDefinitions);
                }
                else if (Array.isArray(typeDefsDefinitions)) {
                    typeDefsDefinitions = typeDefsDefinitions.filter(Boolean);
                    if (typeDefsDefinitions.length) {
                        typeDefs = schemaMerging.mergeTypeDefs(typeDefsDefinitions, {
                            useSchemaDefinition: false
                        });
                    }
                }
                else if (typeDefsDefinitions instanceof graphql.GraphQLSchema) {
                    typeDefs = graphql.parse(common.printSchemaWithDirectives(typeDefsDefinitions));
                }
                else if (typeDefsDefinitions instanceof Promise) {
                    throw new Error(`
          typeDefs of ${this.name} is not sync. So, you need to wait for it.
          Please wait for 'typeDefsAsync' promise before starting your GraphQL Server.
        `);
                }
                else if (typeDefsDefinitions) {
                    typeDefs = typeDefsDefinitions;
                }
            }
            return typeDefs;
        }
        get selfTypeDefsAsync() {
            return new Promise(async (resolve, reject) => {
                try {
                    let typeDefs = null;
                    let typeDefsDefinitions = await this._options.typeDefs;
                    if (typeDefsDefinitions) {
                        if (typeof typeDefsDefinitions === 'function') {
                            this.checkConfiguration();
                            typeDefsDefinitions = await typeDefsDefinitions(this);
                        }
                        if (typeof typeDefsDefinitions === 'string') {
                            typeDefs = graphql.parse(typeDefsDefinitions);
                        }
                        else if (Array.isArray(typeDefsDefinitions)) {
                            typeDefsDefinitions = typeDefsDefinitions.filter(Boolean);
                            if (typeDefsDefinitions.length) {
                                typeDefs = schemaMerging.mergeTypeDefs(typeDefsDefinitions, {
                                    useSchemaDefinition: false
                                });
                            }
                        }
                        else if (typeDefsDefinitions instanceof graphql.GraphQLSchema) {
                            typeDefs = graphql.parse(common.printSchemaWithDirectives(typeDefsDefinitions));
                        }
                        else if (typeDefsDefinitions) {
                            typeDefs = typeDefsDefinitions;
                        }
                    }
                    resolve(typeDefs);
                }
                catch (e) {
                    reject(e);
                }
            });
        }
        get selfResolvers() {
            let resolvers = {};
            let resolversDefinitions = this._options.resolvers;
            if (resolversDefinitions) {
                if (resolversDefinitions instanceof Function) {
                    this.checkConfiguration();
                    resolversDefinitions = this.injector.call(resolversDefinitions, this);
                }
                if (resolversDefinitions instanceof Promise) {
                    throw new Error(`
          Resolvers of ${this.name} is not sync. So, you need to wait for it.
          Please wait for 'resolversAsync' promise before starting your GraphQL Server.
        `);
                }
                if (Array.isArray(resolversDefinitions)) {
                    resolversDefinitions = schemaMerging.mergeResolvers(resolversDefinitions);
                }
                resolvers = resolversDefinitions;
            }
            return resolvers;
        }
        get selfResolversAsync() {
            return new Promise(async (resolve, reject) => {
                try {
                    let resolvers = {};
                    let resolversDefinitions = await this._options.resolvers;
                    if (resolversDefinitions) {
                        if (resolversDefinitions instanceof Function) {
                            this.checkConfiguration();
                            resolversDefinitions = await (await this.injectorAsync).call(resolversDefinitions, this);
                        }
                        if (Array.isArray(resolversDefinitions)) {
                            resolversDefinitions = schemaMerging.mergeResolvers(resolversDefinitions);
                        }
                        resolvers = resolversDefinitions;
                    }
                    resolve(resolvers);
                }
                catch (e) {
                    reject(e);
                }
            });
        }
        get selfImports() {
            let imports = new Array();
            if (this._options.imports) {
                if (typeof this._options.imports === 'function') {
                    this.checkConfiguration();
                    imports = this._options.imports(this);
                }
                else {
                    imports = this._options.imports;
                }
            }
            if (imports.find(module => typeof module === 'undefined')) {
                throw new DependencyModuleUndefinedError(this.name);
            }
            return imports;
        }
        get selfProviders() {
            let providers = new Array();
            const providersDefinitions = this._options.providers;
            if (providersDefinitions) {
                if (typeof providersDefinitions === 'function') {
                    this.checkConfiguration();
                    providers = providersDefinitions(this);
                }
                else {
                    providers = providersDefinitions;
                }
            }
            return [
                {
                    provide: ModuleConfig(this),
                    useValue: this.config,
                    overwrite: true
                },
                {
                    provide: ModuleConfig,
                    useValue: this.config,
                    overwrite: true
                },
                ...providers
            ];
        }
        get selfResolversComposition() {
            let resolversComposition = {};
            const resolversCompositionDefinitions = this._options.resolversComposition;
            if (resolversCompositionDefinitions) {
                if (resolversCompositionDefinitions instanceof Function) {
                    this.checkConfiguration();
                    resolversComposition = this.injector.call(resolversCompositionDefinitions, this);
                }
                else {
                    resolversComposition = resolversCompositionDefinitions;
                }
            }
            return resolversComposition;
        }
        get selfSchemaDirectives() {
            let schemaDirectives = {};
            const schemaDirectivesDefinitions = this._options.schemaDirectives;
            if (schemaDirectivesDefinitions) {
                if (typeof schemaDirectivesDefinitions === 'function') {
                    this.checkConfiguration();
                    schemaDirectives = this.injector.call(schemaDirectivesDefinitions, this);
                }
                else {
                    schemaDirectives = schemaDirectivesDefinitions;
                }
            }
            return schemaDirectives;
        }
        get selfDirectiveResolvers() {
            let directiveResolvers = {};
            const directiveResolversDefinitions = this._options.directiveResolvers;
            if (directiveResolversDefinitions) {
                if (typeof directiveResolversDefinitions === 'function') {
                    this.checkConfiguration();
                    directiveResolvers = this.injector.call(directiveResolversDefinitions, this);
                }
                else {
                    directiveResolvers = directiveResolversDefinitions;
                }
            }
            return directiveResolvers;
        }
        _isScalarResolver(resolver) {
            return (resolver instanceof graphql.GraphQLScalarType ||
                (typeof resolver === 'object' && resolver['serialize'] && resolver['name']));
        }
        addSessionInjectorToSelfResolversContext(selfResolvers) {
            for (const type in selfResolvers) {
                const typeResolvers = selfResolvers[type];
                if (!this._isScalarResolver(typeResolvers)) {
                    for (const prop in selfResolvers[type]) {
                        const resolver = typeResolvers[prop];
                        if (typeof resolver === 'function') {
                            if (prop === '__resolveType' || prop === '__isTypeOf' || prop === '__resolveReference') {
                                typeResolvers[prop] = async (root, appContext, info) => {
                                    if (appContext instanceof Promise) {
                                        appContext = await appContext;
                                    }
                                    else if (typeof appContext === 'undefined') {
                                        appContext = info;
                                    }
                                    info.session = info.session || appContext.session || appContext;
                                    let moduleContext;
                                    try {
                                        moduleContext = await this.context(info.session, true);
                                    }
                                    catch (e) {
                                        const logger = this.selfLogger;
                                        if ('clientError' in logger) {
                                            logger.clientError(e);
                                        }
                                        throw e;
                                    }
                                    info.schema = this._cache.schema || info.schema;
                                    let result;
                                    try {
                                        result = await resolver.call(typeResolvers, root, moduleContext, info);
                                    }
                                    catch (e) {
                                        throw e;
                                    }
                                    return result;
                                };
                            }
                            else {
                                typeResolvers[prop] = async (root, args, appContext, info) => {
                                    if (appContext instanceof Promise) {
                                        appContext = await appContext;
                                    }
                                    else if (typeof appContext === 'undefined') {
                                        appContext = info;
                                    }
                                    info.session = info.session || appContext.session || appContext;
                                    let moduleContext;
                                    try {
                                        moduleContext = await this.context(info.session, true);
                                    }
                                    catch (e) {
                                        const logger = this.selfLogger;
                                        if ('clientError' in logger) {
                                            logger.clientError(e);
                                        }
                                        throw e;
                                    }
                                    info.schema = this._cache.schema || info.schema;
                                    let result;
                                    try {
                                        result = await resolver.call(typeResolvers[prop], root, args, moduleContext, info);
                                    }
                                    catch (e) {
                                        moduleContext.injector.callHookWithArgsAsync({
                                            hook: 'onError',
                                            args: [e],
                                            instantiate: true
                                        });
                                        throw e;
                                    }
                                    return result;
                                };
                            }
                        }
                        else if (resolver && typeof resolver === 'object' && resolver['subscribe']) {
                            const subscriber = resolver['subscribe'];
                            typeResolvers[prop]['subscribe'] = async (root, args, appContext, info) => {
                                if (appContext instanceof Promise) {
                                    appContext = await appContext;
                                }
                                else if (typeof appContext === 'undefined') {
                                    appContext = info;
                                }
                                info.session = info.session || appContext.session || appContext;
                                let moduleContext;
                                try {
                                    moduleContext = await this.context(info.session, true);
                                }
                                catch (e) {
                                    const logger = this.selfLogger;
                                    if ('clientError' in logger) {
                                        logger.clientError(e);
                                    }
                                    throw e;
                                }
                                info.schema = this._cache.schema || info.schema;
                                let result;
                                try {
                                    result = await subscriber.call(typeResolvers[prop], root, args, moduleContext, info);
                                }
                                catch (e) {
                                    moduleContext.injector.callHookWithArgsAsync({
                                        hook: 'onError',
                                        args: [e],
                                        instantiate: true
                                    });
                                    throw e;
                                }
                                return result;
                            };
                        }
                    }
                }
            }
            return selfResolvers;
        }
        addSessionInjectorToSelfResolversCompositionContext(resolversComposition) {
            const visitResolversCompositionElem = (compositionArr) => {
                return [
                    (next) => async (root, args, appContext, info) => {
                        if (appContext instanceof Promise) {
                            appContext = await appContext;
                        }
                        else if (typeof appContext === 'undefined') {
                            appContext = info;
                        }
                        info.session = info.session || appContext.session || appContext;
                        let moduleContext;
                        try {
                            moduleContext = await this.context(info.session, true);
                        }
                        catch (e) {
                            const logger = this.selfLogger;
                            if ('clientError' in logger) {
                                logger.clientError(e);
                            }
                            throw e;
                        }
                        info.schema = this._cache.schema || info.schema;
                        return next(root, args, moduleContext, info);
                    },
                    ...compositionArr
                ];
            };
            for (const path in resolversComposition) {
                if (resolversComposition[path] instanceof Function || resolversComposition[path] instanceof Array) {
                    const compositionArr = asArray(resolversComposition[path]);
                    resolversComposition[path] = visitResolversCompositionElem(compositionArr);
                }
                else {
                    for (const subPath in resolversComposition[path]) {
                        const compositionArr = asArray(resolversComposition[path][subPath]);
                        resolversComposition[path][subPath] = visitResolversCompositionElem(compositionArr);
                    }
                }
            }
            return resolversComposition;
        }
        get selfLogger() {
            let logger = GraphQLModule.defaultLogger;
            if (typeof this._cache.selfLogger === 'undefined') {
                const loggerDefinition = this._options.logger;
                if (loggerDefinition) {
                    if (loggerDefinition instanceof Function) {
                        this.checkConfiguration();
                        this._cache.selfLogger = this.injector.call(loggerDefinition, this);
                    }
                    else {
                        this._cache.selfLogger = loggerDefinition;
                    }
                    logger = this._cache.selfLogger;
                }
                else {
                    this._cache.selfLogger = null;
                }
            }
            else if (this._cache.selfLogger !== null) {
                logger = this._cache.selfLogger;
            }
            return logger;
        }
        get selfCache() {
            let cache = GraphQLModule.defaultCache;
            if (typeof this._cache.selfKeyValueCache === 'undefined') {
                const cacheDefinition = this._options.cache;
                if (cacheDefinition) {
                    if (cacheDefinition instanceof Function) {
                        this.checkConfiguration();
                        this._cache.selfKeyValueCache = this.injector.call(cacheDefinition, this);
                    }
                    else {
                        this._cache.selfKeyValueCache = cacheDefinition;
                    }
                    cache = this._cache.selfKeyValueCache;
                }
                else {
                    this._cache.selfKeyValueCache = null;
                }
            }
            else if (this._cache.selfKeyValueCache !== null) {
                cache = this._cache.selfKeyValueCache;
            }
            return cache;
        }
        get selfResolverValidationOptions() {
            let resolverValidationOptions = {};
            const resolverValidationOptionsDefinitions = this._options.resolverValidationOptions;
            if (resolverValidationOptionsDefinitions) {
                if (resolverValidationOptionsDefinitions instanceof Function) {
                    this.checkConfiguration();
                    resolverValidationOptions = this.injector.call(resolverValidationOptionsDefinitions, this);
                }
                else {
                    resolverValidationOptions = resolverValidationOptionsDefinitions;
                }
            }
            return resolverValidationOptions;
        }
        /**
         * Build a GraphQL `context` object based on a network session.
         * It iterates over all modules by their dependency-based order, and executes
         * `contextBuilder` method.
         * It also in charge of injecting a reference to the application `Injector` to
         * the `context`.
         * The network session is passed to each `contextBuilder` method, and the return
         * value of each `contextBuilder` is merged into a unified `context` object.
         *
         * This method should be in use with your GraphQL manager, such as Apollo-Server.
         *
         * @param session - the network session from `connect`, `express`, etc...
         */
        get context() {
            if (!this._cache.contextBuilder) {
                const selfImports = this.selfImports;
                this._cache.contextBuilder = (session, excludeSession = false, excludeInjector = false) => {
                    session = normalizeSession(session);
                    if (!this._sessionContext$Map.has(session)) {
                        this._sessionContext$Map.set(session, new Promise(async (resolve, reject) => {
                            try {
                                const importsContext = {
                                    injector: undefined
                                };
                                if (selfImports.length) {
                                    const importsContexts = await Promise.all(selfImports.map(module => module.context(session, true, true)));
                                    Object.assign(importsContext, ...importsContexts);
                                }
                                const moduleSessionInfo = new ModuleSessionInfo(this, session);
                                const sessionInjector = await moduleSessionInfo.injectorAsync;
                                let moduleContext;
                                const moduleContextDeclaration = this._options.context;
                                if (moduleContextDeclaration) {
                                    if (moduleContextDeclaration instanceof Function) {
                                        importsContext.injector = sessionInjector;
                                        moduleContext = await moduleContextDeclaration(session, importsContext, moduleSessionInfo);
                                    }
                                    else {
                                        moduleContext = await moduleContextDeclaration;
                                    }
                                }
                                moduleSessionInfo.context = Object.assign(importsContext, moduleContext);
                                const res = session && session['res'];
                                if (res && 'once' in res) {
                                    if (!('_onceFinishListeners' in res)) {
                                        res['_onceFinishListeners'] = [];
                                        function cleanUpOnComplete() {
                                            const onceFinishListeners = res['_onceFinishListeners'];
                                            if (onceFinishListeners) {
                                                for (const onceFinishListener of onceFinishListeners) {
                                                    onceFinishListener();
                                                }
                                                delete res['_onceFinishListeners'];
                                            }
                                        }
                                        res.once('close', cleanUpOnComplete);
                                        res.once('finish', cleanUpOnComplete);
                                    }
                                    res['_onceFinishListeners'].push(() => {
                                        sessionInjector.callHookWithArgs({
                                            hook: 'onResponse',
                                            args: [moduleSessionInfo],
                                            instantiate: true,
                                            async: false
                                        });
                                        this.destroySelfSession(session);
                                    });
                                }
                                sessionInjector.onInstanceCreated = ({ instance }) => {
                                    if (typeof instance !== 'number' &&
                                        typeof instance !== 'boolean' &&
                                        typeof instance !== 'string' &&
                                        'initialize' in instance &&
                                        typeof instance['initialize'] === 'function') {
                                        instance['initialize']({ cache: this.selfCache, context: moduleSessionInfo.context });
                                    }
                                };
                                await sessionInjector.callHookWithArgs({
                                    hook: 'onRequest',
                                    args: [moduleSessionInfo],
                                    instantiate: true,
                                    async: true
                                });
                                resolve(moduleSessionInfo.context);
                            }
                            catch (e) {
                                reject(e);
                            }
                        }));
                    }
                    if (excludeInjector && excludeSession) {
                        return this._sessionContext$Map.get(session);
                    }
                    return this._sessionContext$Map.get(session).then(moduleContext => {
                        const finalContext = Object.assign({}, moduleContext);
                        if (!excludeInjector) {
                            finalContext.injector = this.injector.getSessionInjector(session);
                        }
                        if (!excludeSession) {
                            finalContext['session'] = session;
                        }
                        return finalContext;
                    });
                };
            }
            return this._cache.contextBuilder;
        }
        destroySelfSession(session) {
            this.injector.destroySessionInjector(session);
            this._sessionContext$Map.delete(session);
        }
    }
    GraphQLModule.defaultLogger = console;
    GraphQLModule.defaultCache = new apolloServerCaching.InMemoryLRUCache();
    return GraphQLModule;
})();

exports.DependencyModuleNotFoundError = DependencyModuleNotFoundError;
exports.DependencyModuleUndefinedError = DependencyModuleUndefinedError;
exports.GraphQLModule = GraphQLModule;
exports.ModuleConfig = ModuleConfig;
exports.ModuleConfigRequiredError = ModuleConfigRequiredError;
exports.ModuleSessionInfo = ModuleSessionInfo;
exports.ProviderClassNotDecoratedError = ProviderClassNotDecoratedError;
exports.SchemaNotValidError = SchemaNotValidError;
exports.TypeDefNotFoundError = TypeDefNotFoundError;
