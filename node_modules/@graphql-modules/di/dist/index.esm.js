export { __decorate as decorate } from 'tslib';

const getErrorMsg = (_dependency, _dependent, _moduleName, _dependencyIndex) => {
    const dependencyName = getServiceIdentifierName(_dependency);
    const dependentName = getServiceIdentifierName(_dependent);
    return dependencyName === 'Object'
        ? `
  GraphQL-Modules Error: Dependency Provider Not Valid!
  - Provider in index: #${_dependencyIndex} couldn't be injected into Provider #${dependentName}

  Possible solutions:
  - There might be a circular import issue in Provider #${dependentName}. So make sure imports are valid.
  - Try using Inject decorator!
  `
        : `
    GraphQL-Modules Error: Dependency Provider Not Found!
    - Provider #${dependencyName} at the index #${_dependencyIndex} couldn't be injected into Provider #${getServiceIdentifierName(_dependent)}
    -- Provider #${dependencyName} is not provided in #Module ${_moduleName} scope!

    Possible solutions:
    - Make sure you have imported the module of Provider #${getServiceIdentifierName(_dependency)} in the module of Provider #${getServiceIdentifierName(_dependent)}
    - Check the dependency of the provider at the index #${_dependencyIndex}
    `;
};
class DependencyProviderNotFoundError extends Error {
    constructor(_dependency, _dependent, _moduleName, _dependencyIndex) {
        super(getErrorMsg(_dependency, _dependent, _moduleName, _dependencyIndex));
        this._dependency = _dependency;
        this._dependent = _dependent;
        this._moduleName = _moduleName;
        this._dependencyIndex = _dependencyIndex;
        Object.setPrototypeOf(this, DependencyProviderNotFoundError.prototype);
        Error.captureStackTrace(this, DependencyProviderNotFoundError);
    }
    get dependency() {
        return this._dependency;
    }
    get dependent() {
        return this._dependent;
    }
    get moduleName() {
        return this._moduleName;
    }
    get dependencyIndex() {
        return this._dependencyIndex;
    }
}

class ServiceIdentifierNotFoundError extends Error {
    constructor(_serviceIdentifier, _dependent, _dependencyIndex) {
        super(`
      GraphQL-Modules Error: Dependency Provider Not Found!
      - Provider #${getServiceIdentifierName(_serviceIdentifier)} not provided in #Module ${_dependent} scope!

      Possible solutions:
      - Check if you have this provider in your module.
      - Check if you have the module of this provider imported in your dependent modules.
    `);
        this._serviceIdentifier = _serviceIdentifier;
        this._dependent = _dependent;
        this._dependencyIndex = _dependencyIndex;
        Object.setPrototypeOf(this, ServiceIdentifierNotFoundError.prototype);
        Error.captureStackTrace(this, ServiceIdentifierNotFoundError);
    }
    get dependent() {
        return this._dependent;
    }
    get serviceIdentifier() {
        return this._serviceIdentifier;
    }
    get dependencyIndex() {
        return this._dependencyIndex;
    }
}

class ProviderNotValidError extends Error {
    constructor(_moduleName, _serviceIdentifier) {
        super(`
      GraphQL-Modules Error: Provider is not valid!
      - #Module #${_moduleName} provides an invalid #Provider #${getServiceIdentifierName(_serviceIdentifier)}!

      Possible solutions:
      - Provider must be a class itself,
        or provides a valid identifier with 'useValue', 'useFactory' or 'useClass'.
    `);
        this._moduleName = _moduleName;
        this._serviceIdentifier = _serviceIdentifier;
        Object.setPrototypeOf(this, ProviderNotValidError.prototype);
        Error.captureStackTrace(this, ProviderNotValidError);
    }
    get moduleName() {
        return this._moduleName;
    }
    get serviceIdentifier() {
        return this._serviceIdentifier;
    }
}

class ProviderAlreadyDefinedError extends Error {
    constructor(_moduleName, _serviceIdentifier) {
        super(`
      GraphQL-Modules Error: Provider has been already defined!
      - #Module #${_moduleName} already has a #Provider #${getServiceIdentifierName(_serviceIdentifier)}.

      Possible solutions:
      - Provider must have 'overwrite: true' field.
    `);
        this._moduleName = _moduleName;
        this._serviceIdentifier = _serviceIdentifier;
        Object.setPrototypeOf(this, ProviderAlreadyDefinedError.prototype);
        Error.captureStackTrace(this, ProviderAlreadyDefinedError);
    }
    get moduleName() {
        return this._moduleName;
    }
    get serviceIdentifier() {
        return this._serviceIdentifier;
    }
}

const DESIGN_PARAMTYPES = 'design:paramtypes';
const DESIGN_TYPE = 'design:type';
const PROVIDER_OPTIONS = 'provider-options';
const PROPERTY_KEYS = 'property-keys';
function getServiceIdentifierName(serviceIdentifier) {
    if (typeof serviceIdentifier === 'function' && isType(serviceIdentifier)) {
        return serviceIdentifier.name;
    }
    else if (typeof serviceIdentifier !== 'undefined') {
        return serviceIdentifier.toString();
    }
    else {
        return 'undefined';
    }
}
function isType(v) {
    return typeof v === 'function' && 'prototype' in v;
}
function isTypeProvider(v) {
    return isType(v);
}
function isValueProvider(v) {
    return 'useValue' in v;
}
function isClassProvider(v) {
    return 'useClass' in v && isType(v.useClass);
}
function isFactoryProvider(v) {
    return 'useFactory' in v && typeof v.useFactory === 'function';
}

function Inject(dependency) {
    return (target, propertyKey, index) => {
        const allDependencies = Reflect.getMetadata(DESIGN_PARAMTYPES, target) || [];
        const propertyKeys = Reflect.getMetadata(PROPERTY_KEYS, target.constructor || target) || [];
        if (typeof propertyKey === 'undefined') {
            if (typeof index !== 'undefined') {
                allDependencies[index] = dependency;
            }
        }
        else {
            const designType = dependency || Reflect.getMetadata(DESIGN_TYPE, target, propertyKey);
            Reflect.defineMetadata(DESIGN_TYPE, designType, target, propertyKey);
            propertyKeys.push(propertyKey);
        }
        Reflect.defineMetadata(DESIGN_PARAMTYPES, allDependencies, target);
        Reflect.defineMetadata(PROPERTY_KEYS, propertyKeys, target.constructor || target);
        return target;
    };
}
function InjectFunction(...dependencies) {
    return (target) => {
        Reflect.defineMetadata(DESIGN_PARAMTYPES, dependencies, target);
        return target;
    };
}

function Injectable(options = {}) {
    return target => {
        const existingDesignParamTypes = Reflect.getMetadata(DESIGN_PARAMTYPES, target) || [];
        Reflect.defineMetadata(DESIGN_PARAMTYPES, existingDesignParamTypes, target);
        Reflect.defineMetadata(PROVIDER_OPTIONS, options, target);
        const propertyKeys = Reflect.getMetadata(PROPERTY_KEYS, target.constructor) || [];
        Reflect.defineMetadata(PROPERTY_KEYS, propertyKeys, target.constructor);
        return target;
    };
}

var ProviderScope;
(function (ProviderScope) {
    ProviderScope["Application"] = "APPLICATION";
    ProviderScope["Request"] = "REQUEST";
    ProviderScope["Session"] = "SESSION";
})(ProviderScope || (ProviderScope = {}));

class Injector {
    constructor(options = {}) {
        this.options = options;
        this._classMap = new Map();
        this._factoryMap = new Map();
        this._applicationScopeInstanceMap = new Map();
        this._sessionScopeInstanceMap = new Map();
        this._applicationScopeServiceIdentifiers = new Array();
        this._requestScopeServiceIdentifiers = new Array();
        this._sessionScopeServiceIdentifiers = new Array();
        this._hookServiceIdentifiersMap = new Map();
        this._name = this.options.name || Date.now().toString();
        this._injectorScope = this.options.injectorScope || ProviderScope.Application;
        this._defaultProviderScope = this.options.defaultProviderScope || this._injectorScope;
        this._hooks = this.options.hooks || new Array();
        this._initialProviders = this.options.initialProviders || new Array();
        this._children = this.options.children || new Array();
        this.onInstanceCreated = () => { };
        this._sessionSessionInjectorMap = new WeakMap();
        for (const provider of this._initialProviders) {
            if (provider) {
                this.provide(provider);
            }
        }
    }
    addChild(...children) {
        for (const child of children) {
            this._children.push(child);
        }
    }
    removeChild(...children) {
        for (const child of children) {
            this._children.splice(this._children.indexOf(child), 1);
        }
    }
    hasChild(child) {
        return this._children.includes(child);
    }
    getScopeInstanceMap(providerScope = this._injectorScope) {
        switch (providerScope) {
            case ProviderScope.Application:
                return this._applicationScopeInstanceMap;
            case ProviderScope.Session:
                return this._sessionScopeInstanceMap;
            case ProviderScope.Request:
                return new Map();
        }
    }
    provide(provider) {
        if (isTypeProvider(provider)) {
            const options = Reflect.getMetadata(PROVIDER_OPTIONS, provider);
            if (this.has(provider)) {
                throw new ProviderAlreadyDefinedError(this._name, provider);
            }
            this._classMap.set(provider, provider);
            switch ((options && options.scope) || this._defaultProviderScope) {
                case ProviderScope.Application:
                    this._applicationScopeServiceIdentifiers.push(provider);
                    break;
                case ProviderScope.Request:
                    this._requestScopeServiceIdentifiers.push(provider);
                    break;
                case ProviderScope.Session:
                    this._sessionScopeServiceIdentifiers.push(provider);
                    break;
            }
            for (const hook of this._hooks) {
                if (hook in provider.prototype) {
                    if (!this._hookServiceIdentifiersMap.has(hook)) {
                        this._hookServiceIdentifiersMap.set(hook, []);
                    }
                    this._hookServiceIdentifiersMap.get(hook).push(provider);
                }
            }
            return;
        }
        if (this.has(provider.provide)) {
            if (!provider.overwrite) {
                throw new ProviderAlreadyDefinedError(this._name, provider.provide);
            }
            else {
                this._classMap.delete(provider.provide);
                this._factoryMap.delete(provider.provide);
                this.getScopeInstanceMap().delete(provider.provide);
                this._applicationScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
                this._sessionScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
                this._requestScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
            }
        }
        if (isValueProvider(provider)) {
            this.getScopeInstanceMap().set(provider.provide, provider.useValue);
        }
        else if (isClassProvider(provider)) {
            const providedClassOptions = provider.provide['prototype']
                ? Reflect.getMetadata(PROVIDER_OPTIONS, provider.provide)
                : null;
            const useClassOptions = Reflect.getMetadata(PROVIDER_OPTIONS, provider.useClass);
            provider.scope =
                provider.scope ||
                    (providedClassOptions && providedClassOptions.scope) ||
                    (useClassOptions && useClassOptions.scope);
            this._classMap.set(provider.provide, provider.useClass);
            for (const hook of this._hooks) {
                if (hook in provider.useClass.prototype) {
                    if (!this._hookServiceIdentifiersMap.has(hook)) {
                        this._hookServiceIdentifiersMap.set(hook, []);
                    }
                    this._hookServiceIdentifiersMap.get(hook).push(provider.provide);
                }
            }
        }
        else if (isFactoryProvider(provider)) {
            this._factoryMap.set(provider.provide, provider.useFactory);
        }
        else {
            throw new ProviderNotValidError(this._name, provider['provide'] && provider);
        }
        switch (provider.scope || this._defaultProviderScope) {
            case ProviderScope.Application:
                this._applicationScopeServiceIdentifiers.push(provider.provide);
                break;
            case ProviderScope.Request:
                this._requestScopeServiceIdentifiers.push(provider.provide);
                break;
            case ProviderScope.Session:
                this._sessionScopeServiceIdentifiers.push(provider.provide);
                break;
        }
    }
    has(serviceIdentifier) {
        return (this.getScopeInstanceMap(ProviderScope.Application).has(serviceIdentifier) ||
            this.getScopeInstanceMap(ProviderScope.Session).has(serviceIdentifier) ||
            this._classMap.has(serviceIdentifier) ||
            this._factoryMap.has(serviceIdentifier));
    }
    remove(serviceIdentifier) {
        this.getScopeInstanceMap().delete(serviceIdentifier);
        this._classMap.delete(serviceIdentifier);
        this._factoryMap.delete(serviceIdentifier);
    }
    get scopeServiceIdentifiers() {
        switch (this._injectorScope) {
            case ProviderScope.Application:
                return this._applicationScopeServiceIdentifiers;
            case ProviderScope.Request:
                return this._requestScopeServiceIdentifiers;
            case ProviderScope.Session:
                return this._sessionScopeServiceIdentifiers;
        }
    }
    get(serviceIdentifier, dependencyIndex) {
        const applicationScopeInstanceMap = this.getScopeInstanceMap(ProviderScope.Application);
        const sessionScopeInstanceMap = this.getScopeInstanceMap(ProviderScope.Session);
        if (sessionScopeInstanceMap.has(serviceIdentifier)) {
            return sessionScopeInstanceMap.get(serviceIdentifier);
        }
        else if (applicationScopeInstanceMap.has(serviceIdentifier)) {
            return applicationScopeInstanceMap.get(serviceIdentifier);
        }
        else if (this._classMap.has(serviceIdentifier)) {
            const RealClazz = this._classMap.get(serviceIdentifier);
            try {
                const dependencies = Reflect.getMetadata(DESIGN_PARAMTYPES, RealClazz) || [];
                const dependencyInstances = dependencies.map((dependency, dependencyIndex) => this.get(dependency, dependencyIndex));
                const instance = new RealClazz(...dependencyInstances);
                const propertyKeys = Reflect.getMetadata(PROPERTY_KEYS, RealClazz) || [];
                for (const propertyKey of propertyKeys) {
                    const dependency = Reflect.getMetadata(DESIGN_TYPE, RealClazz.prototype, propertyKey);
                    if (dependency) {
                        Object.defineProperty(instance, propertyKey, {
                            value: this.get(dependency, propertyKeys.indexOf(propertyKey))
                        });
                    }
                }
                if (this._applicationScopeServiceIdentifiers.includes(serviceIdentifier)) {
                    this._applicationScopeInstanceMap.set(serviceIdentifier, instance);
                }
                if (this._sessionScopeServiceIdentifiers.includes(serviceIdentifier)) {
                    this._sessionScopeInstanceMap.set(serviceIdentifier, instance);
                }
                this.onInstanceCreated({ serviceIdentifier, instance });
                return instance;
            }
            catch (e) {
                if (e instanceof ServiceIdentifierNotFoundError) {
                    throw new DependencyProviderNotFoundError(e.serviceIdentifier, RealClazz, this._name, e.dependencyIndex);
                }
                else {
                    throw e;
                }
            }
        }
        else if (this._factoryMap.has(serviceIdentifier)) {
            const factory = this._factoryMap.get(serviceIdentifier);
            const instance = this.call(factory, this);
            if (this._applicationScopeServiceIdentifiers.includes(serviceIdentifier)) {
                this._applicationScopeInstanceMap.set(serviceIdentifier, instance);
            }
            if (this._sessionScopeServiceIdentifiers.includes(serviceIdentifier)) {
                this._sessionScopeInstanceMap.set(serviceIdentifier, instance);
            }
            this.onInstanceCreated({ serviceIdentifier, instance });
            return instance;
        }
        else {
            for (const child of this._children) {
                try {
                    const instance = child.get(serviceIdentifier);
                    return instance;
                }
                catch (e) {
                    if (e instanceof ServiceIdentifierNotFoundError && e.serviceIdentifier === serviceIdentifier) {
                        continue;
                    }
                    else {
                        throw e;
                    }
                }
            }
            throw new ServiceIdentifierNotFoundError(serviceIdentifier, this._name, dependencyIndex);
        }
    }
    hasSessionInjector(session) {
        return this._sessionSessionInjectorMap.has(session);
    }
    getSessionInjector(session) {
        if (!this._sessionSessionInjectorMap.has(session)) {
            const sessionInjector = new Injector({
                name: this._name + '_SESSION',
                injectorScope: ProviderScope.Session,
                hooks: this._hooks,
                children: this._children.map(child => child.getSessionInjector(session))
            });
            sessionInjector._hookServiceIdentifiersMap = this._hookServiceIdentifiersMap;
            sessionInjector._applicationScopeInstanceMap = this._applicationScopeInstanceMap;
            sessionInjector._classMap = this._classMap;
            sessionInjector._factoryMap = this._factoryMap;
            sessionInjector._applicationScopeServiceIdentifiers = this._applicationScopeServiceIdentifiers;
            sessionInjector._requestScopeServiceIdentifiers = this._requestScopeServiceIdentifiers;
            sessionInjector._sessionScopeServiceIdentifiers = [...this._sessionScopeServiceIdentifiers];
            this._sessionSessionInjectorMap.set(session, sessionInjector);
        }
        return this._sessionSessionInjectorMap.get(session);
    }
    destroySessionInjector(session) {
        return this._sessionSessionInjectorMap.delete(session);
    }
    call(fn, thisArg) {
        if ('hasMetadata' in Reflect && Reflect.hasMetadata(DESIGN_PARAMTYPES, fn)) {
            const dependencies = Reflect.getMetadata(DESIGN_PARAMTYPES, fn);
            const instances = dependencies.map((dependency, dependencyIndex) => this.get(dependency, dependencyIndex));
            return fn.call(thisArg, ...instances);
        }
        return fn.call(thisArg, thisArg);
    }
    async hasHook(hook) {
        return this._hookServiceIdentifiersMap.has(hook);
    }
    callHookWithArgs({ async, ...options }) {
        if (async) {
            return this.callHookWithArgsAsync(options);
        }
        else {
            return this.callHookWithArgsSync(options);
        }
    }
    callHookWithArgsSync({ hook, args, instantiate }) {
        const finalResult = {};
        const serviceIdentifiers = this._hookServiceIdentifiersMap.get(hook);
        if (serviceIdentifiers) {
            Object.assign(finalResult, ...serviceIdentifiers.map(serviceIdentifier => {
                if (!instantiate && !this.getScopeInstanceMap().has(serviceIdentifier)) {
                    return {};
                }
                const instance = this.get(serviceIdentifier);
                if (instance) {
                    const result = instance[hook](...args);
                    if (result) {
                        return result;
                    }
                }
                return {};
            }));
        }
        return finalResult;
    }
    async callHookWithArgsAsync({ hook, args, instantiate }) {
        const finalResult = {};
        const serviceIdentifiers = this._hookServiceIdentifiersMap.get(hook);
        if (serviceIdentifiers) {
            Object.assign(finalResult, ...(await Promise.all(serviceIdentifiers.map(async (serviceIdentifier) => {
                if (!instantiate && !this.getScopeInstanceMap().has(serviceIdentifier)) {
                    return {};
                }
                const instance = this.get(serviceIdentifier);
                if (instance) {
                    const result = await instance[hook](...args);
                    if (result) {
                        return result;
                    }
                }
                return {};
            }))));
        }
        return finalResult;
    }
}

export { DESIGN_PARAMTYPES, DESIGN_TYPE, DependencyProviderNotFoundError, Inject, InjectFunction, Injectable, Injector, PROPERTY_KEYS, PROVIDER_OPTIONS, ProviderAlreadyDefinedError, ProviderNotValidError, ProviderScope, ServiceIdentifierNotFoundError, getServiceIdentifierName, isClassProvider, isFactoryProvider, isType, isTypeProvider, isValueProvider };
