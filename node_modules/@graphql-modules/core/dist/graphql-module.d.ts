import { IDirectiveResolvers, IResolverValidationOptions } from 'graphql-tools';
import { ResolversComposerMapping } from '@graphql-toolkit/common';
import { Provider, Injector, ProviderScope } from '@graphql-modules/di';
import { DocumentNode, GraphQLSchema, GraphQLScalarType } from 'graphql';
import { ModuleSessionInfo } from './module-session-info';
import { ModuleContext, SubscriptionHooks, Resolvers } from './types';
import { KeyValueCache } from 'apollo-server-caching';
declare type MaybePromise<T> = Promise<T> | T;
export interface LogMethod {
    (message: string, ...meta: any[]): void;
    (message: Error, ...meta: any[]): void;
    (message: string | Error): void;
}
export interface Logger {
    log?: LogMethod;
    debug?: LogMethod;
    info?: LogMethod;
    error?: LogMethod;
    clientError?: LogMethod;
    warn?: LogMethod;
}
/**
 * A context builder method signature for `contextBuilder`.
 */
export declare type BuildContextFn<Config, Session extends object, Context, PreviousContext = any> = (session: Session, currentContext: ModuleContext<PreviousContext>, moduleSessionInfo: ModuleSessionInfo<Config, Session, Context>) => Promise<Context> | Context;
export interface SchemaDirectives {
    [name: string]: any;
}
export declare type GraphQLModuleOption<Option, Config, Session extends object, Context> = Option | ((module: GraphQLModule<Config, Session, Context>, ...args: any[]) => Option);
export declare type GraphQLModuleOptionAsync<Option, Config, Session extends object, Context> = GraphQLModuleOption<Option, Config, Session, Context> | Promise<Option> | ((module: GraphQLModule<Config, Session, Context>, ...args: any[]) => Promise<Option>);
/**
 * Defined the structure of GraphQL module options object.
 */
export interface GraphQLModuleOptions<Config, Session extends object, Context, SelfResolvers extends Resolvers<any, ModuleContext<Context>>> {
    /**
     * The name of the module. Use it later to get your `ModuleConfig(name)` or to declare
     * a dependency to this module (in another module)
     */
    name?: string;
    /**
     * A definition of GraphQL type definitions, as string or `DocumentNode`.
     * Arrays are also accepted, and they will get merged.
     * You can also pass a function that will get the module's config as argument, and should return
     * the type definitions.
     */
    typeDefs?: GraphQLModuleOption<MaybePromise<string | DocumentNode | GraphQLSchema | Array<string | DocumentNode | GraphQLSchema>>, Config, Session, Context>;
    /**
     * Resolvers object, or a function will get the module's config as argument, and should
     * return the resolvers object.
     */
    resolvers?: GraphQLModuleOption<MaybePromise<SelfResolvers | Array<SelfResolvers>>, Config, Session, Context>;
    /**
     * Context builder method. Use this to add your own fields and data to the GraphQL `context`
     * of each execution of GraphQL.
     */
    context?: BuildContextFn<Config, Session, Context> | Promise<Context> | Context;
    /**
     * The dependencies that this module need to run correctly, you can either provide the `GraphQLModule`,
     * or provide a string with the name of the other module.
     * Adding a dependency will effect the order of the type definition building, resolvers building and context
     * building.
     */
    imports?: GraphQLModuleOption<Array<GraphQLModule<any, Session, any>>, Config, Session, Context>;
    /**
     * A list of `Providers` to load into the GraphQL module.
     * It could be either a `class` or a value/class instance.
     * All loaded class will be loaded as Singletons, and the instance will be
     * shared across all GraphQL executions.
     */
    providers?: GraphQLModuleOption<Provider[], Config, Session, Context>;
    /** Object map between `Type.field` to a function(s) that will wrap the resolver of the field  */
    resolversComposition?: GraphQLModuleOption<ResolversComposerMapping, Config, Session, Context>;
    schemaDirectives?: GraphQLModuleOption<SchemaDirectives, Config, Session, Context>;
    directiveResolvers?: GraphQLModuleOption<IDirectiveResolvers, Config, Session, Context>;
    logger?: GraphQLModuleOption<Logger, Config, Session, Context>;
    extraSchemas?: GraphQLModuleOption<GraphQLSchema[], Config, Session, Context>;
    middleware?: (module: GraphQLModule<Config, Session, Context>, ...args: any[]) => Partial<ModuleCache<Session, Context>> | void;
    cache?: GraphQLModuleOption<KeyValueCache, Config, Session, Context>;
    configRequired?: boolean;
    resolverValidationOptions?: GraphQLModuleOption<IResolverValidationOptions, Config, Session, Context>;
    defaultProviderScope?: GraphQLModuleOption<ProviderScope, Config, Session, Context>;
    subscriptionHooks?: SubscriptionHooks;
    visitSchemaDirectives?: boolean;
}
/**
 * Returns a dependency injection token for getting a module's configuration object by
 * the module's name.
 * You can use this later with `@Inject` in your `Provider`s.
 *
 * @param module
 * @constructor
 */
export declare const ModuleConfig: (module: string | GraphQLModule<any, any, any, Partial<{
    [key: string]: (() => any) | GraphQLScalarType | import("graphql-tools").IEnumResolver | Partial<import("graphql-tools").IResolverObject<any, any, any>> | import("graphql-tools").IResolverOptions<any, any, any>;
}>> | ((module?: void) => GraphQLModule | string)) => symbol;
export interface ModuleCache<Session extends object, Context> {
    injector: Injector<Session>;
    schema: GraphQLSchema;
    typeDefs: DocumentNode;
    resolvers: any;
    schemaDirectives: SchemaDirectives;
    contextBuilder: (session: Session, excludeSession?: boolean) => Promise<ModuleContext<Context>>;
    extraSchemas: GraphQLSchema[];
    directiveResolvers: IDirectiveResolvers;
    subscriptionHooks: SubscriptionHooks;
    imports: GraphQLModule[];
    selfKeyValueCache: KeyValueCache;
    selfLogger: Logger;
}
export interface ModuleCacheAsync<Session extends object> {
    schemaAsync: Promise<GraphQLSchema>;
    typeDefsAsync: Promise<DocumentNode>;
    resolversAsync: Promise<any>;
    injectorAsync: Promise<Injector<Session>>;
}
/**
 * Represents a GraphQL module that has it's own types, resolvers, context and business logic.
 * You can read more about it in the Documentation section. {@link /docs/introduction/modules}
 *
 * You can also specific `Config` generic to tell TypeScript what's the structure of your
 * configuration object to use later with `forRoot`
 */
export declare class GraphQLModule<Config = any, Session extends object = any, Context = any, SelfResolvers extends Resolvers<any, ModuleContext<Context>> = Resolvers<any, ModuleContext<Context>>> {
    private _options;
    private _moduleConfig?;
    private _cache;
    private _cacheAsync;
    private _exclusionsFromSchema;
    /**
     * Creates a new `GraphQLModule` instance, merged it's type definitions and resolvers.
     * @param options - module configuration
     */
    constructor(_options?: GraphQLModuleOptions<Config, Session, Context, SelfResolvers>, _moduleConfig?: Config);
    /**
     * Creates another instance of the module using a configuration
     * @param config - the config object
     */
    forRoot(config: Config): GraphQLModule<Config, Session, Context, SelfResolvers>;
    forChild(config: Config): GraphQLModule<Config, Session, Context, SelfResolvers>;
    withExclusionsFromSchema(exclusionsFromSchema: string[]): GraphQLModule<Config, Session, Context, SelfResolvers>;
    clearCache(): void;
    mock(partialCache?: Partial<ModuleCache<Session, Context>>): this;
    resetMock(): this;
    private checkConfiguration;
    get name(): string;
    get config(): Config;
    /**
     * Gets the application `GraphQLSchema` object.
     * If the schema object is not built yet, it compiles
     * the `typeDefs` and `resolvers` into `GraphQLSchema`
     */
    get schema(): GraphQLSchema;
    get schemaAsync(): Promise<GraphQLSchema>;
    /**
     * Gets the application dependency-injection injector
     */
    get injector(): Injector<Session>;
    get injectorAsync(): Promise<Injector<Session>>;
    get extraSchemas(): GraphQLSchema[];
    /**
     * Gets the merged GraphQL type definitions as one string
     */
    get typeDefs(): DocumentNode;
    get typeDefsAsync(): Promise<DocumentNode>;
    get resolvers(): any;
    get resolversAsync(): Promise<any>;
    get schemaDirectives(): SchemaDirectives;
    private paramsOnOperationResult$Map;
    private opIdOnOperationCompleteResult$Map;
    get subscriptions(): SubscriptionHooks;
    get selfDefaultProviderScope(): ProviderScope;
    get selfExtraSchemas(): GraphQLSchema[];
    /**
     * Returns the GraphQL type definitions of the module
     * @return a `string` with the merged type definitions
     */
    get selfTypeDefs(): DocumentNode;
    get selfTypeDefsAsync(): Promise<DocumentNode>;
    get selfResolvers(): SelfResolvers;
    get selfResolversAsync(): Promise<SelfResolvers>;
    get selfImports(): GraphQLModule<any, Session, any, Partial<{
        [key: string]: (() => any) | GraphQLScalarType | import("graphql-tools").IEnumResolver | Partial<import("graphql-tools").IResolverObject<any, any, any>> | import("graphql-tools").IResolverOptions<any, any, any>;
    }>>[];
    get selfProviders(): Provider[];
    get selfResolversComposition(): ResolversComposerMapping;
    get selfSchemaDirectives(): SchemaDirectives;
    get selfDirectiveResolvers(): IDirectiveResolvers;
    private _isScalarResolver;
    private addSessionInjectorToSelfResolversContext;
    private addSessionInjectorToSelfResolversCompositionContext;
    static defaultLogger: Logger;
    get selfLogger(): Logger;
    static defaultCache: KeyValueCache;
    get selfCache(): KeyValueCache;
    get selfResolverValidationOptions(): IResolverValidationOptions;
    private _sessionContext$Map;
    /**
     * Build a GraphQL `context` object based on a network session.
     * It iterates over all modules by their dependency-based order, and executes
     * `contextBuilder` method.
     * It also in charge of injecting a reference to the application `Injector` to
     * the `context`.
     * The network session is passed to each `contextBuilder` method, and the return
     * value of each `contextBuilder` is merged into a unified `context` object.
     *
     * This method should be in use with your GraphQL manager, such as Apollo-Server.
     *
     * @param session - the network session from `connect`, `express`, etc...
     */
    get context(): (session: Session, excludeSession?: boolean, excludeInjector?: boolean) => Promise<ModuleContext<Context>>;
    private destroySelfSession;
}
export {};
